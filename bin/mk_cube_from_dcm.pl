#!/usr/bin/perl
#
use strict;

if(@ARGV+0 != 2){ die "usage: mk_mtp_cube.pl <cube file> <dcm parfile>"; }

my $ref_cube=$ARGV[0];
my $dcm_file=$ARGV[1];

my @Z; # nuclear charges (for atom type)
my @coords_dcm;
my @ex; # local atomix x-axis for DCM charges
my @ey; 
my @ez;
# i.e. this is a terminal atom with only one bonded partner)

# open reference cube file for reading
open(INP,"<$ref_cube");

# open the output cube file
open(OUT,">dcm.cube");
print OUT "ESP generated by multipole moments\n";
print OUT "Grid and coordinates taken from $ref_cube\n";

my $tobohr=1.88973;

# read header from cube file
my $nl=1; # line number in file
my $natm; # number of atoms in molecule
my @origin; # origin for 3D grid
my $nxpts; # number of points along x-direction
my $nypts; 
my $nzpts;
my $dx; # x grid spacing
my $dy;
my $dz;
my @coords; # O nuclear coords
my $atm=0; # atom counter

while(<INP>){
  chomp;
  my $line=$_;
  my @a=split;

  if($nl==3){ # global origin
    $natm=$a[0];
    @origin=($a[1], $a[2], $a[3]);
    print OUT "$line\n";
  }elsif($nl==4){ # x-grid definition
    $nxpts=$a[0];
    $dx=$a[1];
    if($a[2] != 0.0 || $a[3] != 0.0){ die "error: grid must be cubic!\n"; }
    print OUT "$line\n";
  }elsif($nl==5){ # y-grid definition
    $nypts=$a[0];
    $dy=$a[2];
    if($a[1] != 0.0 || $a[3] != 0.0){ die "error: grid must be cubic!\n"; }
    print OUT "$line\n";
  }elsif($nl==6){ # z-grid definition
    $nzpts=$a[0];
    $dz=$a[3];
    if($a[1] != 0.0 || $a[2] != 0.0){ die "error: grid must be cubic!\n"; }
    print OUT "$line\n";
  }elsif($nl>6 && $nl<=($natm+6)){ # atomic coords
    $Z[$atm] = $a[0];
    $coords[$atm][0]=$a[2];
    $coords[$atm][1]=$a[3];
    $coords[$atm++][2]=$a[4];
    print OUT "$line\n";
  }

  if($nl>6+$natm){ last; }

  $nl++;
}

print "number atoms = $natm\n";
print "number x pts = $nxpts\n";
print "number y pts = $nypts\n";
print "number z pts = $nzpts\n";
print "x spacing    = $dx\n";
print "y spacing    = $dy\n";
print "z spacing    = $dz\n";
print "global origin:  $origin[0]  $origin[1]  $origin[2]\n";
print "nuclear coords:\n";
for(my $n=0; $n<$natm; $n++){
  print "$Z[$n] $coords[$n][0] $coords[$n][1] $coords[$n][2]\n";
}

# open dcm parameter file for reading
open(DCM,"<$dcm_file");

$nl=1;
my @lines;
my $nframes;
while(<DCM>){
  chomp;
  my @a=split;
  if($nl>4) {$lines[@lines+0]=$_; } # store frames
  if($nl==1 && $a[0] != 1){ die "Only one residue may be defined in dcm parameter file (found $a[0])\n";  }
  if($nl==4){ # number of frames
    $nframes=$a[0];
  }
  $nl++;
}

$nl=0;
my $nf=0; # frame
my @nq; # dcm charges per atom
my @fatm; # atom indices in each frame
my @af; # primary frame of atom (where charges are defined)
for(my $n=0; $n<$nframes; $n++){
  # parse atoms in frame
  my @a=split(' ',$lines[$nl++]);
  $fatm[$nf][0]=$a[0]-1;
  $fatm[$nf][1]=$a[1]-1;
  $fatm[$nf][2]=$a[2]-1;
  if($a[3] ne "BO"){ die "axis system type must be BO\n"; }
  # now parse charges for atoms in frame
  for(my $l=0; $l<3; $l++){
    @a=split(' ',$lines[$nl++]);
    if($nq[$fatm[$nf][$l]] > 0 && $a[0] > 0){
      my $nn=$fatm[$nf][$l]+1;
      die "error reading .dcm file, atom $nn has charges in more than 1 frame!\n";
    }
    if($nq[$fatm[$nf][$l]] == 0){ # if we didn't already read charges for this atom
      $af[$fatm[$nf][$l]]=$n;
      $nq[$fatm[$nf][$l]]=$a[0];
      if($a[1] != 0){ die "polarizable sites currently not supported\n"; }
      for(my $m=0; $m<$nq[$fatm[$nf][$l]]; $m++){
        @a=split(' ',$lines[$nl++]);
        $coords_dcm[$fatm[$nf][$l]][$m][0]=$tobohr*$a[0];
        $coords_dcm[$fatm[$nf][$l]][$m][1]=$tobohr*$a[1];
        $coords_dcm[$fatm[$nf][$l]][$m][2]=$tobohr*$a[2];
        $coords_dcm[$fatm[$nf][$l]][$m][3]=$a[3];
      }
    }
  }
  $nf++;
}


# get local axes for atoms
for(my $nf=0; $nf<$nframes; $nf++){ # loop over frames
  my $a1=$fatm[$nf][0]; # 1st atom in frame
  my $a2=$fatm[$nf][1];
  my $a3=$fatm[$nf][2];

  my @tex;
  my @tey;
  my @tez;

  # atom 1
  $tez[$a1][0]=$coords[$a1][0]-$coords[$a2][0];
  $tez[$a1][1]=$coords[$a1][1]-$coords[$a2][1];
  $tez[$a1][2]=$coords[$a1][2]-$coords[$a2][2];
  print "Frame $nf: atom1 $a1, atom2 $a2, atom3 $a3\n";
  my $Rz=sqrt($tez[$a1][0]**2+$tez[$a1][1]**2+$tez[$a1][2]**2);
  $tez[$a1][0]/=$Rz;
  $tez[$a1][1]/=$Rz;
  $tez[$a1][2]/=$Rz;

  my @v1; # second bond for cross product
  $v1[0]=$coords[$a3][0]-$coords[$a2][0];
  $v1[1]=$coords[$a3][1]-$coords[$a2][1];
  $v1[2]=$coords[$a3][2]-$coords[$a2][2];
  my $R1=sqrt($v1[0]**2+$v1[1]**2+$v1[2]**2);
  $v1[0]/=$R1;
  $v1[1]/=$R1;
  $v1[2]/=$R1;

  # y axis is cross product of z-axis with bond B
  $tey[$a1][0]=$tez[$a1][1]*$v1[2]-$tez[$a1][2]*$v1[1];
  $tey[$a1][1]=$tez[$a1][2]*$v1[0]-$tez[$a1][0]*$v1[2];
  $tey[$a1][2]=$tez[$a1][0]*$v1[1]-$tez[$a1][1]*$v1[0];
  my $Ry=sqrt($tey[$a1][0]**2+$tey[$a1][1]**2+$tey[$a1][2]**2);
  $tey[$a1][0]/=$Ry;
  $tey[$a1][1]/=$Ry;
  $tey[$a1][2]/=$Ry;

  # x axis is cross product of ez and ey
  $tex[$a1][0]=$tez[$a1][1]*$tey[$a1][2]-$tez[$a1][2]*$tey[$a1][1];
  $tex[$a1][1]=$tez[$a1][2]*$tey[$a1][0]-$tez[$a1][0]*$tey[$a1][2];
  $tex[$a1][2]=$tez[$a1][0]*$tey[$a1][1]-$tez[$a1][1]*$tey[$a1][0];

  # atom 2
  for(my $n=0; $n<3; $n++){
    $tex[$a2][$n]=$tex[$a1][$n];
    $tey[$a2][$n]=$tey[$a1][$n];
    $tez[$a2][$n]=$tez[$a1][$n];
  }

  # atom 3
  for(my $n=0; $n<3; $n++){
    $tey[$a3][$n]=$tey[$a1][$n];
    $tez[$a3][$n]=$v1[$n];
  }

  # x axis is cross product of ez and ey
  $tex[$a3][0]=$tez[$a3][1]*$tey[$a3][2]-$tez[$a3][2]*$tey[$a3][1];
  $tex[$a3][1]=$tez[$a3][2]*$tey[$a3][0]-$tez[$a3][0]*$tey[$a3][2];
  $tex[$a3][2]=$tez[$a3][0]*$tey[$a3][1]-$tez[$a3][1]*$tey[$a3][0];

  # only apply these axes to atom if this is its primary frame
  if($af[$a1]==$nf){
    for(my $n=0; $n<3; $n++){
      $ex[$a1][$n]=$tex[$a1][$n];
      $ey[$a1][$n]=$tey[$a1][$n];
      $ez[$a1][$n]=$tez[$a1][$n];
    }
  }
  if($af[$a2]==$nf){
    for(my $n=0; $n<3; $n++){
      $ex[$a2][$n]=$tex[$a2][$n];
      $ey[$a2][$n]=$tey[$a2][$n];
      $ez[$a2][$n]=$tez[$a2][$n];
    }
  }
  if($af[$a3]==$nf){
    for(my $n=0; $n<3; $n++){
      $ex[$a3][$n]=$tex[$a3][$n];
      $ey[$a3][$n]=$tey[$a3][$n];
      $ez[$a3][$n]=$tez[$a3][$n];
    }
  }
}

# Place DCM charges relative to atoms
my @q_coord; # DCM charges in global axis
my $tq=0; # total number dcm charges
for(my $n=0; $n<$natm; $n++){
  my $nn=$n+1;
  print "atom $nn: $nq[$n] charges\n";
  for(my $m=0; $m<$nq[$n]; $m++){
    my $tx=$coords[$n][0]+$coords_dcm[$n][$m][0]*$ex[$n][0]+$coords_dcm[$n][$m][1]*$ey[$n][0]+$coords_dcm[$n][$m][2]*$ez[$n][0];
    my $ty=$coords[$n][1]+$coords_dcm[$n][$m][0]*$ex[$n][1]+$coords_dcm[$n][$m][1]*$ey[$n][1]+$coords_dcm[$n][$m][2]*$ez[$n][1];
    my $tz=$coords[$n][2]+$coords_dcm[$n][$m][0]*$ex[$n][2]+$coords_dcm[$n][$m][1]*$ey[$n][2]+$coords_dcm[$n][$m][2]*$ez[$n][2];
    $q_coord[$tq][0]=$tx;
    $q_coord[$tq][1]=$ty;
    $q_coord[$tq][2]=$tz;
    $q_coord[$tq++][3]=$coords_dcm[$n][$m][3];
  }
}

# Diagnostic: print local atomic axes to xyz file for visualization:
print_axes();
# And print DCM charges in global frame:
print_charges();

# begin calculating ESP from multipoles at each grid point
for(my $ix=0;$ix<$nxpts;$ix++){
  for(my $iy=0;$iy<$nypts;$iy++){
    for(my $iz=0;$iz<$nzpts;$iz++){
      my $x=$origin[0]+$ix*$dx;
      my $y=$origin[1]+$iy*$dy;
      my $z=$origin[2]+$iz*$dz;
      my $pot=calc_pot($x,$y,$z);
      printf OUT "%13.5e",$pot;
      if($iz % 6 == 5){ print OUT "\n"; }
    }
    if($nzpts % 6 != 0){
      print OUT "\n";
    }
  }
}

sub calc_pot {
  # coords of current point passed to subroutine:
  my $x=$_[0];
  my $y=$_[1];
  my $z=$_[2];

  my $Vtot=0.0;

  # loop over charges
  for(my $n=0; $n<$tq; $n++){
    my $rx=$x-$q_coord[$n][0];
    my $ry=$y-$q_coord[$n][1];
    my $rz=$z-$q_coord[$n][2];
    my $r=sqrt($rx**2+$ry**2+$rz**2);
    $Vtot+=$q_coord[$n][3]/$r;
  }
  
  return($Vtot);
}

sub print_axes {

  open(XYZ,">axes.xyz");
  my $nsite=$natm*4;
  print XYZ "$nsite\nLocal axes (diagnostic file)\n";

  for(my $n=0; $n<$natm; $n++){
    my @tx=($coords[$n][0]+$ex[$n][0], $coords[$n][1]+$ex[$n][1],$coords[$n][2]+$ex[$n][2]);
    my @ty=($coords[$n][0]+$ey[$n][0], $coords[$n][1]+$ey[$n][1],$coords[$n][2]+$ey[$n][2]);
    my @tz=($coords[$n][0]+$ez[$n][0], $coords[$n][1]+$ez[$n][1],$coords[$n][2]+$ez[$n][2]);
    print XYZ "O  $coords[$n][0] $coords[$n][1] $coords[$n][2]\n";
    print XYZ "H  $tx[0] $tx[1] $tx[2]\n";
    print XYZ "H  $ty[0] $ty[1] $ty[2]\n";
    print XYZ "H  $tz[0] $tz[1] $tz[2]\n";
  }

}

sub print_charges {

  open(XYZ,">dcm_charges.xyz");
  my $nsite=$natm+$tq;
  print XYZ "$nsite\nDCM charges in global frame (diagnostic file)\n";

  for(my $n=0; $n<$natm; $n++){
    print XYZ "O  $coords[$n][0] $coords[$n][1] $coords[$n][2]\n";
  }
  for(my $n=0; $n<$tq; $n++){
    print XYZ "H  $q_coord[$n][0]  $q_coord[$n][1]  $q_coord[$n][2]  $q_coord[$n][3]\n";
  }

}
